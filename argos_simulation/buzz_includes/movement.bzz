# Calculates a random movement avoiding the outer walls
function random_movement_no_sensing() {
  # Rotation
  var cur_yaw = ((pose.orientation.yaw % (2. * math.pi)) / math.pi) * 180
  var offset_yaw = rand_uniform(-MAX_ROT_SPEED, MAX_ROT_SPEED)
  
  # Avoid the walls
  if (math.abs(math.abs(pose.position.x)-ARENA_SIZE/2)<ARENA_EDGE_TOLERANCE) {
    if (pose.position.x > 0){
      if (cur_yaw < 90) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw > 270) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
    if (pose.position.x < 0){
      if (cur_yaw < 270 and cur_yaw > 180) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw > 90 and cur_yaw < 180) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }  
  }
  if (math.abs(math.abs(pose.position.y)-ARENA_SIZE/2)<ARENA_EDGE_TOLERANCE){
    if (pose.position.y > 0){
      if (cur_yaw < 180 and cur_yaw > 90) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw < 90) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
    if (pose.position.y < 0){
      if (cur_yaw < 360 and cur_yaw > 270) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw < 270 and cur_yaw > 180) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
  }

  # Rotation command
  rotate(offset_yaw * math.pi / 180.0)

  # Translation command + add a fake noisy odometry measurement to the local graph
  pose_id_ = move_forward_fake_odometry(TRANS_SPEED/SIMULATION_TIME_DIVIDER, SIMULATION_TIME_DIVIDER)
}