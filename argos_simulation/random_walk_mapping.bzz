include "buzz_includes/vec2.bzz"
include "buzz_includes/string.bzz"
 
# Constants
TRANS_SPEED = 1.0
MAX_ROT_SPEED = 15
ARENA_SIZE = 100.0
ARENA_EDGE_TOLERANCE = 15.0

# Global variables
var pose_id_ = 0
var current_other_robot_ground_truth_pose_
var is_there_a_new_other_robot_pose_ = 0
var is_there_a_new_loop_closure_measurement_ = 0
var last_poses
# Calculates a random movement avoiding the outer walls
function random_movement() {
  # Rotation
  var cur_yaw = ((pose.orientation.yaw % (2. * math.pi)) / math.pi) * 180
  var offset_yaw = rand_uniform(-MAX_ROT_SPEED, MAX_ROT_SPEED)
  
  # Avoid the walls
  if (math.abs(math.abs(pose.position.x)-ARENA_SIZE/2)<ARENA_EDGE_TOLERANCE) {
    if (pose.position.x > 0){
      if (cur_yaw < 90) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw > 270) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
    if (pose.position.x < 0){
      if (cur_yaw < 270 and cur_yaw > 180) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw > 90 and cur_yaw < 180) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }  
  }
  if (math.abs(math.abs(pose.position.y)-ARENA_SIZE/2)<ARENA_EDGE_TOLERANCE){
    if (pose.position.y > 0){
      if (cur_yaw < 180 and cur_yaw > 90) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw < 90) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
    if (pose.position.y < 0){
      if (cur_yaw < 360 and cur_yaw > 270) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw < 270 and cur_yaw > 180) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
  }

  # Rotation command
  rotate(offset_yaw * math.pi / 180.0)

  # Translation command + add a fake noisy odometry measurement to the local graph
  pose_id_ = move_forward_fake_odometry(TRANS_SPEED)
}

# Function to detect inter-robot loop closures and save them
function loop_closure_detection() {

  # Add fake loop closure on every rendez-vous
  if (is_there_a_new_other_robot_pose_) {
    # Add fake loop closure factor in the graph
    compute_fake_rendezvous_loop_closures(current_other_robot_ground_truth_pose_.value.pose_id, current_other_robot_ground_truth_pose_.value.x, 
                                      current_other_robot_ground_truth_pose_.value.y, current_other_robot_ground_truth_pose_.value.z, 
                                      current_other_robot_ground_truth_pose_.value.yaw, current_other_robot_ground_truth_pose_.rid, pose_id_)
    is_there_a_new_other_robot_pose_ = 0  
    is_there_a_new_loop_closure_measurement_ = 1

    # Separator visualization
    debug.rays.add(0,200,0, current_loop_closure_measurement.x,current_loop_closure_measurement.y,current_loop_closure_measurement.z)
  }

}

# Function share information between robots.
function communication() {
  # Broadcast ground truth pose to compute loop closure measurement
  this_robot_ground_truth_pose = {
    .x = pose.position.x,
    .y = pose.position.y,
    .z = pose.position.z,
    .yaw = pose.orientation.yaw,
    .pose_id = pose_id_
  }
  neighbors.broadcast("information_for_fake_loop_closure", this_robot_ground_truth_pose)

  # Listen to neighbor poses
  neighbors.listen("information_for_fake_loop_closure",
    function(vid, value, rid) {   
      # To avoid version control, the robot with the lowest ID in the pair computes the loop closure  
      if (id < rid) {
        current_other_robot_ground_truth_pose_ = {
          .value = value,
          .rid = rid
        }          
        is_there_a_new_other_robot_pose_ = 1
      }
    }
  )

  # Broadcast loop closure measurement
  if (is_there_a_new_loop_closure_measurement_) {
    neighbors.broadcast("loop_closure_measurement", current_loop_closure_measurement)
    is_there_a_new_loop_closure_measurement_ = 0
  }

  # Listen to neighbor poses
  neighbors.listen("loop_closure_measurement",
    function(vid, value, rid) {   
      # Send information to controller to add loop closure to graph if it concern this robot
      add_loop_closure_to_local_graph(value.robot_1_id, value.robot_2_id, value.robot_1_pose_id, 
                                      value.robot_2_pose_id, value.x, value.y, value.z, 
                                      value.q_x, value.q_y, value.q_z, value.q_w)
    }
  )
}

# Executed at init time
function init() {
  # Compute colors
  var nr_robots = 10
  var float_id = float(id)
  var r = int((float_id/(nr_robots/2)) * 200)
  var g = int(math.abs(float_id - (nr_robots/2))/(nr_robots/2) * 200)
  var b = int(200 - float_id*(200/nr_robots))
  # Show trajectory for debugging
  debug.trajectory.enable(10000, r, g, b)
  # Initialization of random number generator. The controller function use time+id as the seed.
  srand(id)
  # Take off command for the Spiri drone model
  takeoff()
  # Message flags initialization
  is_there_a_new_other_robot_pose_ = 0
  is_there_a_new_loop_closure_measurement_ = 0
  # Global variable initialization
  last_poses = {}
  last_poses[0] = pose
  last_poses[1] = pose
  last_poses[2] = pose
}
 
# Executed every time step
function step() {
  # Update pose history
  last_poses[2] = last_poses[1]
  last_poses[1] = last_poses[0]
  last_poses[0] = pose
  # Communication
  # Note that incoming messages (listen) are executed always first (after sensing), 
  # see Section II of "Buzz: An Extensible Programming Language for Self-Organizing Heterogeneous Robot Swarms"
  communication()
  # Move
  random_movement()
  # Loop closure detection
  loop_closure_detection()
}
 
# Execute at exit
function destroy() {
}