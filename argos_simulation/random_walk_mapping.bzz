include "buzz_includes/vec2.bzz"
include "buzz_includes/string.bzz"
 
# Constants
TRANS_SPEED = 1.0
MAX_ROT_SPEED = 15
ARENA_SIZE = 200.0
ARENA_EDGE_TOLERANCE = 15.0

# Utilitary function
function table_copy(t) {
  var t2 = {}
  foreach(t, function(key, value) {
      t2[key] = value
    })
  return t2
}

# Global variable
var pose_id_ = 0

# Calculates and actuates the flocking interaction
function random_movement() {
  # Rotation
  var cur_yaw = ((pose.orientation.yaw % (2. * math.pi)) / math.pi) * 180
  var offset_yaw = rand_uniform(-MAX_ROT_SPEED, MAX_ROT_SPEED)
  
  # Avoid the walls
  if (math.abs(math.abs(pose.position.x)-ARENA_SIZE/2)<ARENA_EDGE_TOLERANCE) {
    if (pose.position.x > 0){
      if (cur_yaw < 90) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw > 270) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
    if (pose.position.x < 0){
      if (cur_yaw < 270 and cur_yaw > 180) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw > 90 and cur_yaw < 180) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }  
  }
  if (math.abs(math.abs(pose.position.y)-ARENA_SIZE/2)<ARENA_EDGE_TOLERANCE){
    if (pose.position.y > 0){
      if (cur_yaw < 180 and cur_yaw > 90) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw < 90) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
    if (pose.position.y < 0){
      if (cur_yaw < 360 and cur_yaw > 270) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw < 270 and cur_yaw > 180) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
  }

  rotate(offset_yaw * math.pi / 180.0)

  # Translation
  pose_id_ = move_forward(TRANS_SPEED)
}

# Function to detect inter-robot loop closures and save them
function loop_closure_detection() {
  # Loop closures
  # Broadcast estimate
  estimate = {
    .x = pose.position.x,
    .y = pose.position.y,
    .z = pose.position.z,
    .yaw = pose.orientation.yaw,
    .pose_id = pose_id_
  } # Get estimate from controller
  ground_truth = {
    .x = pose.position.x,
    .y = pose.position.y,
    .z = pose.position.z,
    .yaw = pose.orientation.yaw
  }
  current_estimate = {
    .estimate = estimate,
    .ground_truth = ground_truth # To compute the fake loop closure measurement
  }
  neighbors.broadcast("current_estimate", current_estimate)

  # Listen to neighbor estimates
  neighbors.listen("current_estimate",
    function(vid, value, rid) {     
      # Display loop closure
      diff_x = value.ground_truth.x - pose.position.x
      diff_y = value.ground_truth.y - pose.position.y
      display_z = value.ground_truth.z - pose.position.z
      rot_angle = pose.orientation.yaw
      display_x = diff_x * math.cos(rot_angle) + diff_y * math.sin(rot_angle)
      display_y = -diff_x * math.sin(rot_angle) + diff_y * math.cos(rot_angle)

      debug.rays.add(0,200,0, display_x,display_y,display_z)
      # Add fake loop closure factor in the graph
      add_fake_rendezvous_loop_closures(value.estimate.x, value.estimate.y, value.estimate.z, value.estimate.yaw, value.estimate.pose_id,
                        value.ground_truth.x, value.ground_truth.y, value.ground_truth.z, value.ground_truth.yaw, rid)
    }
  )
}

# Executed at init time
function init() {
  var nr_robots = 10
  var float_id = float(id)
  var r = int((float_id/(nr_robots/2)) * 200)
  var g = int(math.abs(float_id - (nr_robots/2))/(nr_robots/2) * 200)
  var b = int(200 - float_id*(200/nr_robots))

  debug.trajectory.enable(10000, r, g, b)
  srand(id)
  takeoff()
}
 
# Executed every time step
function step() {
  # Move
  random_movement()
  # Loop closure detection
  loop_closure_detection()
}
 
# Execute at exit
function destroy() {
}