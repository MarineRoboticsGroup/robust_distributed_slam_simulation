include "buzz_includes/vec2.bzz"
include "buzz_includes/string.bzz"
 
# Constants
TRANS_SPEED = 1.0
MAX_ROT_SPEED = 15
ARENA_SIZE = 100.0
ARENA_EDGE_TOLERANCE = 15.0
LOOP_CLOSURE_RANGE = 15.0
EXPERIMENT_LENGTH = 100
MAX_NUMBER_MEASUREMENT_PER_MESSAGE = 2

# Global variables
var pose_id_ = 0
var current_other_robot_ground_truth_poses_ = {}
var current_number_of_other_robot_poses_ = 0
var current_step_ = 0
# Calculates a random movement avoiding the outer walls
function random_movement() {
  # Rotation
  var cur_yaw = ((pose.orientation.yaw % (2. * math.pi)) / math.pi) * 180
  var offset_yaw = rand_uniform(-MAX_ROT_SPEED, MAX_ROT_SPEED)
  
  # Avoid the walls
  if (math.abs(math.abs(pose.position.x)-ARENA_SIZE/2)<ARENA_EDGE_TOLERANCE) {
    if (pose.position.x > 0){
      if (cur_yaw < 90) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw > 270) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
    if (pose.position.x < 0){
      if (cur_yaw < 270 and cur_yaw > 180) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw > 90 and cur_yaw < 180) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }  
  }
  if (math.abs(math.abs(pose.position.y)-ARENA_SIZE/2)<ARENA_EDGE_TOLERANCE){
    if (pose.position.y > 0){
      if (cur_yaw < 180 and cur_yaw > 90) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw < 90) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
    if (pose.position.y < 0){
      if (cur_yaw < 360 and cur_yaw > 270) {
        offset_yaw = offset_yaw + MAX_ROT_SPEED
      }
      if (cur_yaw < 270 and cur_yaw > 180) {
        offset_yaw = offset_yaw - MAX_ROT_SPEED
      }
    }
  }

  # Rotation command
  rotate(offset_yaw * math.pi / 180.0)

  # Translation command + add a fake noisy odometry measurement to the local graph
  pose_id_ = move_forward_fake_odometry(TRANS_SPEED)
}

# Function to detect inter-robot loop closures and save them
function loop_closure_detection() {
  
  number_of_loop_closures = math.min(current_number_of_other_robot_poses_, MAX_NUMBER_MEASUREMENT_PER_MESSAGE)

  current_loop_closure_measurements = {}
  current_loop_closure_measurements.number = number_of_loop_closures
  current_loop_closure_measurements.measurements = {}
  # Add fake loop closure on every rendez-vous
  for (i = 0, i < number_of_loop_closures, i = i + 1) {
    current_other_robot_ground_truth_pose = current_other_robot_ground_truth_poses_[i]

    # Add fake loop closure factor in the graph
    is_outlier = compute_fake_rendezvous_loop_closures(
                                      current_other_robot_ground_truth_pose.value.pose_id, current_other_robot_ground_truth_pose.value.x, 
                                      current_other_robot_ground_truth_pose.value.y, current_other_robot_ground_truth_pose.value.z, 
                                      current_other_robot_ground_truth_pose.value.yaw, current_other_robot_ground_truth_pose.rid, pose_id_)

    current_loop_closure_measurements.measurements[i] = current_loop_closure_measurement
    # Separator visualization
    if (is_outlier == 1) {
      debug.rays.add(200,0,0, current_loop_closure_measurement.x,current_loop_closure_measurement.y,current_loop_closure_measurement.z)
    } else {
      debug.rays.add(0,200,0, current_loop_closure_measurement.x,current_loop_closure_measurement.y,current_loop_closure_measurement.z)
    }
  }
  current_number_of_other_robot_poses_ = 0

  # Broadcast loop closure measurements
  neighbors.broadcast("loop_closure_measurements", current_loop_closure_measurements)
}

# Function share information between robots.
function communication() {
  # Broadcast ground truth pose to compute loop closure measurement
  this_robot_ground_truth_pose = {
    .x = pose.position.x,
    .y = pose.position.y,
    .z = pose.position.z,
    .yaw = pose.orientation.yaw,
    .pose_id = pose_id_
  }
  neighbors.broadcast("information_for_fake_loop_closure", this_robot_ground_truth_pose)

  # Listen to neighbor poses
  neighbors.listen("information_for_fake_loop_closure",
    function(vid, value, rid) {   
      # To avoid version control, the robot with the lowest ID in the pair computes the loop closure
      # To avoid packet loss, we don't compute new loop closure when they are to close to disconnect. 
      # We also need to avoid adding loop closures on the first node (0) because it would conflict with the prior (anchoring)
      # Finally we stop adding loop closures once the experiment is done. 
      if (id < rid and neighbors.get(rid).distance/100 < LOOP_CLOSURE_RANGE and value.pose_id > 0 and current_step_ < EXPERIMENT_LENGTH) {
        current_other_robot_ground_truth_pose = {
          .value = value,
          .rid = rid
        }          
        current_other_robot_ground_truth_poses_[current_number_of_other_robot_poses_] = current_other_robot_ground_truth_pose
        current_number_of_other_robot_poses_ = current_number_of_other_robot_poses_ + 1
      }
    }
  )

  # Listen to neighbor poses
  neighbors.listen("loop_closure_measurements",
    function(vid, value, rid) {   
      for (i = 0, i < value.number, i = i + 1) {
        # Send information to controller to add loop closure to graph if it concern this robot
        measurement = value.measurements[i]
        if (measurement.robot_1_id == id or measurement.robot_2_id == id) {
          add_loop_closure_to_local_graph(measurement.robot_1_id, measurement.robot_2_id, measurement.robot_1_pose_id, 
                                          measurement.robot_2_pose_id, measurement.x, measurement.y, measurement.z, 
                                          measurement.q_x, measurement.q_y, measurement.q_z, measurement.q_w)
        }
      }
    }
  )
}

# Executed at init time
function init() {
  # Compute colors
  var nr_robots = 10
  var float_id = float(id)
  var r = int((float_id/(nr_robots/2)) * 200)
  var g = int(math.abs(float_id - (nr_robots/2))/(nr_robots/2) * 200)
  var b = int(200 - float_id*(200/nr_robots))
  # Show trajectory for debugging
  debug.trajectory.enable(10000, r, g, b)
  # Initialization of random number generator. The controller function use time+id as the seed.
  srand(id)
  # Take off command for the Spiri drone model
  takeoff()
}
 
# Executed every time step
function step() {
  # Communication
  # Note that incoming messages (listen) are executed always first (after sensing), 
  # see Section II of "Buzz: An Extensible Programming Language for Self-Organizing Heterogeneous Robot Swarms"
  communication()
  # Move
  random_movement()
  # Loop closure detection
  loop_closure_detection()
  # Increment number of steps
  current_step_ = current_step_ + 1 
}
 
# Execute at exit
function destroy() {
}