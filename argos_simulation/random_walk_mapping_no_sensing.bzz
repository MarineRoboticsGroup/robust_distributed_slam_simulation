include "buzz_includes/buzz_utils/vec2.bzz"
include "buzz_includes/buzz_utils/string.bzz"
include "config/buzz_script_parameters.bzz"
include "config/cpp_controller_parameters.bzz"
include "config/cpp_controller_no_sensing_parameters.bzz"
include "buzz_includes/global_variables.bzz"
include "buzz_includes/debug.bzz"
include "buzz_includes/movement.bzz"
include "buzz_includes/separator.bzz"
include "buzz_includes/pose_graph_optimization.bzz"

# Executed at init time
function init() {
  # Initialization of random number generator. The controller function use time+id as the seed.
  srand(id)
  # Take off command for the Spiri drone model
  takeoff()
  # Load parameters
  load_cpp_controller_no_sensing_parameters()
  load_cpp_controller_parameters()
  # Show trajectory for debugging
  show_colored_trajectory()
}
 
# Executed every time step
function step() {
  if (current_step_ == 0) {
    # Init optimizer
    init_optimizer(OPTIMIZER_PERIOD)
  }
  receive_optimizer_state_from_neighbors()
  send_optimizer_state_to_neighbors()
  if (optimizer_state() == 0) { # Not optimizing
    # Set speeds
    current_translation_speed = TRANS_SPEED
    current_max_rotation_speed = MAX_ROT_SPEED
    # Reset flags
    has_received_rotation_estimates = 0
    has_received_pose_estimates = 0
    # Move
    random_movement_no_sensing()
    # Communication
    # Note that incoming messages (listen) are executed always first (after sensing), 
    # see Section II of "Buzz: An Extensible Programming Language for Self-Organizing Heterogeneous Robot Swarms"
    separators_detection_communication_no_sensing()
    # Separator detection
    random_number = rand_uniform(0, SEPARATOR_DETECTION_PERIOD) + 1
    if ((not has_sent_separator) and random_number >= math.abs(current_step_ % SEPARATOR_DETECTION_PERIOD - SEPARATOR_DETECTION_PERIOD) ) {
      separators_detection_no_sensing()
      has_sent_separator = 1
    }
    if (current_step_ % SEPARATOR_DETECTION_PERIOD == 0) {
      has_sent_separator = 0
    }
    send_start_optimization_flag()
    listen_for_start_optimization_flag()
  } else if (optimizer_state() == 1) {  # Start optimizing
    start_optimization()
    # Move
    random_movement_no_sensing()
    debug.print("Start Optimization")
  } else if (optimizer_state() == 2) {  # Rotation Estimation
    # Receive finished flags from other robots
    receive_rotation_estimation_finished_flag_from_neighbors()
    # Receive estimates from neighbors
    receive_and_update_rotation_estimates_from_neighbors()
    # Send estimates to neighbors
    send_rotation_estimates_to_neighbors()
    # Send finished flag if stopping conditions are met
    send_rotation_estimation_finished_flag_to_neighbors()
    # Move
    random_movement_no_sensing()
    debug.print("Rotation Estimation")
  } else if (optimizer_state() == 4) {  # PoseEstimation
    # Receive finished flags from other robots
    receive_pose_estimation_finished_flag_from_neighbors()
    # Receive estimates from neighbors
    receive_and_update_pose_estimates_from_neighbors()
    # Send estimates to neighbors
    send_pose_estimates_to_neighbors()
    # Send finished flag if stopping conditions are met
    send_pose_estimation_finished_flag_to_neighbors()
    # Move
    random_movement_no_sensing()
    debug.print("Pose Estimation")
  } else if (optimizer_state() == 5) {  # End optimization
    debug.print("End Optimization")
    # Move faster to distance robots
    current_translation_speed = 10*TRANS_SPEED
    current_rotation_speed = 20*ROT_SPEED
    random_movement_no_sensing()
    current_translation_speed = TRANS_SPEED
    current_rotation_speed = ROT_SPEED
  } else {
    # Move
    random_movement_no_sensing()
  }
  # Increment number of steps
  current_step_ = current_step_ + 1 
}
 
# Execute at exit
function destroy() {
}
